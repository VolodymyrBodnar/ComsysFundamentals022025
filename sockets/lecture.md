### **Основи роботи Socket**

Сокети – це програмний інтерфейс для комунікації між пристроями у мережі. Вони дозволяють двом процесам, які можуть працювати як на одному комп'ютері, так і на різних пристроях, обмінюватися даними через мережу. В основі сокетного програмування лежить модель клієнт-сервер, де один процес виступає як сервер, що очікує на з'єднання, а інший – як клієнт, який ініціює це з'єднання.

Сокети працюють поверх протоколів передачі даних. Найпоширенішими є TCP (Transmission Control Protocol) і UDP (User Datagram Protocol). TCP забезпечує надійну, впорядковану та безпомилкову доставку повідомлень, встановлюючи стійке з'єднання між клієнтом і сервером. Цей протокол підходить для застосунків, де важлива цілісність даних, наприклад, для чатів, файлообміну чи веб-запитів. Натомість UDP є більш легким і швидким, але не гарантує доставки чи правильного порядку отримання пакетів, що робить його ідеальним для застосунків, де швидкість важливіша за точність, таких як відеостріми або онлайн-ігри.

Сокетна взаємодія починається з ініціалізації сокета, після чого сервер прив’язує його до певної IP-адреси та порту, що дозволяє клієнтам знайти його у мережі. Сервер переводить сокет у режим очікування підключень, і коли клієнт ініціює з'єднання, сервер приймає його та створює новий сокет для обміну даними з цим конкретним клієнтом. Після встановлення з'єднання обидві сторони можуть надсилати та отримувати дані, поки не закриють сокет.

У Python стандартна бібліотека `socket` дозволяє працювати з мережевими сокетами на низькому рівні. Щоб створити TCP-сокет, достатньо викликати `socket.socket(socket.AF_INET, socket.SOCK_STREAM)`, де `AF_INET` вказує на використання IPv4, а `SOCK_STREAM` означає роботу з TCP. Для UDP використовується `SOCK_DGRAM`. Після створення сокета його необхідно прив’язати до певного порту, використовуючи `bind()`, після чого сервер може почати слухати вхідні з'єднання за допомогою `listen()`. Коли клієнт підключається, сервер приймає з'єднання викликом `accept()`, після чого починається обмін повідомленнями через `send()` і `recv()`.

Клієнт, у свою чергу, створює сокет і встановлює з'єднання, використовуючи `connect()`, після чого може надсилати та отримувати дані. Основною відмінністю клієнтської частини є відсутність операцій `bind()` і `listen()`, оскільки клієнт не очікує підключень, а лише ініціює їх.

Розуміння цієї моделі є основою для подальшого вивчення практичних прикладів, зокрема побудови ехо-сервера та чат-сервера, а також переходу до WebSockets, які розширюють можливості постійного з'єднання між клієнтом і сервером.

### **Архітектури комунікації у мережах**

Перед тим як заглиблюватися у WebSockets, варто зрозуміти основні моделі мережевої взаємодії. Класична модель клієнт-сервер передбачає, що один сервер обробляє запити від клієнтів, тоді як у Peer-to-Peer (P2P) моделі кожен вузол може бути і клієнтом, і сервером одночасно. WebSockets найчастіше використовуються у клієнт-серверних додатках, але є способи інтегрувати їх у P2P через проксі або ретранслятори.

Також слід розглянути підходи **Push vs. Pull**. HTTP-запити працюють за pull-моделлю (клієнт запитує — сервер відповідає), тоді як WebSockets дозволяють серверу "пушити" повідомлення клієнту без очікування запитів. Це важливо для реального часу, де необхідно миттєво реагувати на події.

### **Push vs. Pull: Як працює передача даних у вебі**

У вебі існують два основні підходи для передачі даних між клієнтом і сервером: **Pull** (витягування) та **Push** (проштовхування). Вони відрізняються тим, **хто ініціює комунікацію** та як часто оновлюються дані.

---

## **Pull (Клієнт ініціює запит)**

Pull-модель працює за принципом **"запит-відповідь"**:

1. Клієнт (браузер або інша програма) надсилає запит на сервер (наприклад, через HTTP).
2. Сервер отримує запит, обробляє його та надсилає відповідь.
3. Якщо клієнту потрібні нові дані, він повинен зробити ще один запит.

Це стандартний механізм для більшості вебсайтів. Наприклад, коли ми відкриваємо сторінку в браузері, він запитує HTML-код, сервер його повертає, і комунікація закінчується.

### **Приклади Pull-комунікації**

- **HTTP-запити (REST API, GraphQL)** – браузер запитує дані, а сервер відповідає.
- **AJAX polling** – клієнт кожні N секунд надсилає запит (`setInterval(fetchData, 5000)`).
- **Long polling** – клієнт надсилає запит, а сервер чекає появи нових даних перед тим, як відповісти (утримує з'єднання).

Pull підходить для **статичних** або **рідко оновлюваних даних**, наприклад, коли користувач відкриває статтю або переглядає товари в інтернет-магазині. Але якщо необхідно отримувати **миттєві оновлення**, постійні запити створюють **високе навантаження на сервер**, навіть якщо нових даних немає.

---

## **Push (Сервер ініціює відправку)**

Push-модель працює за принципом **"сервер надсилає дані сам"**:

1. Клієнт встановлює **постійне з'єднання** із сервером.
2. Коли на сервері з’являються нові дані, він відразу відправляє їх клієнту **без очікування запиту**.
3. Клієнт отримує дані та оновлює інтерфейс (наприклад, додає нове повідомлення в чаті).

Це значно ефективніше для **реального часу**, оскільки сервер не змушений відповідати на безліч "порожніх" запитів від клієнтів.

### **Приклади Push-комунікації**

- **WebSockets** – клієнт відкриває постійне з'єднання, сервер надсилає дані, коли вони з’являються.
- **Server-Sent Events (SSE)** – сервер "стрімить" оновлення в браузер через HTTP-з’єднання.
- **Push-нотифікації** – сервер надсилає повідомлення в мобільний або браузерний застосунок.
- **MQTT (IoT)** – легковаговий протокол для миттєвої комунікації між пристроями.

Push-модель підходить, коли дані **оновлюються часто і непередбачувано**, наприклад:

- Чати та месенджери (повідомлення мають приходити одразу).
- Біржові котирування (ціни змінюються миттєво).
- Онлайн-ігри (сервер має швидко передавати зміни в грі).

---

## **Чому WebSockets – це Push?**

WebSockets дозволяють встановити **постійне з'єднання** між клієнтом і сервером. Це означає, що сервер може надсилати дані клієнту **без очікування запиту**. Наприклад, у чаті, коли один користувач надсилає повідомлення, сервер одразу передає його всім підключеним клієнтам.

### **Чому Push ефективніший за Pull у реальному часі?**

1. **Менше навантаження на сервер** – сервер не обробляє сотні "порожніх" запитів, а надсилає дані тільки тоді, коли вони з'являються.
2. **Менша затримка** – немає очікування між запитом клієнта і відповіддю сервера. Дані передаються миттєво.
3. **Зручність для інтерактивних застосунків** – користувач отримує оновлення в реальному часі без необхідності перезавантажувати сторінку.

---

## **Порівняння Pull та Push**

|Характеристика|Pull (запит-відповідь)|Push (постійне з'єднання)|
|---|---|---|
|**Хто ініціює запит?**|Клієнт|Сервер|
|**Чи потрібно постійно робити запити?**|Так|Ні|
|**Підходить для реального часу?**|Ні|Так|
|**Типові технології**|REST API, AJAX, Long Polling|WebSockets, SSE, MQTT|
|**Приклад використання**|Отримання новинної стрічки|Чат, біржові котирування, онлайн-ігри|

---

## **Коли вибирати WebSockets (Push), а коли HTTP-запити (Pull)?**

- Якщо дані оновлюються **раз на хвилину і рідше**, WebSockets не потрібні – простіше використовувати HTTP-запити.
- Якщо оновлення мають бути **миттєвими** (наприклад, у грі або чаті) – WebSockets підходять краще.
- Якщо клієнти мають **нестабільний інтернет**, WebSockets можуть бути неефективними (вони залежать від стабільного з’єднання).

### **Гібридні рішення**

У багатьох застосунках використовують **змішані** підходи. Наприклад, біржова платформа може використовувати WebSockets для **миттєвих оновлень**, але також дозволяти користувачеві оновлювати сторінку вручну через HTTP-запит, якщо WebSocket-з'єднання розірвалося.

---
### **Протоколи реального часу: Порівняння WebSockets, SSE, gRPC, MQTT та WebRTC**

Реальний час у вебі означає, що дані передаються миттєво, без необхідності користувачу постійно оновлювати сторінку або чекати відповіді на запит. Для цього використовуються різні протоколи, кожен з яких має свої особливості, переваги та обмеження.

---

## **1. WebSockets (Двосторонній зв'язок, постійне з'єднання)**

**🔹 Як працює:**  
WebSockets встановлюють **постійне TCP-з'єднання** між клієнтом і сервером, що дозволяє **обмінюватися даними в обох напрямках у будь-який момент часу**. Це ефективна альтернатива традиційним HTTP-запитам, оскільки після початкового рукопотискання (`handshake`) не потрібно повторно відкривати з'єднання.

**🔹 Основні особливості:**

- Двостороння комунікація: сервер може надсилати дані клієнту без очікування запиту.
- Підтримка в більшості браузерів (`WebSocket API`).
- Працює поверх TCP (але немає вбудованої надійності на рівні протоколу, окрім того, що забезпечує TCP).
- Підтримує лише текстові та бінарні повідомлення (відсутня вбудована підтримка потокового відео/аудіо).

**🔹 Де використовуються:**  
✅ Чати, месенджери  
✅ Онлайн-ігри  
✅ Фінансові біржі (котирування)  
✅ Панелі моніторингу (диспетчерські системи, аналітика)

**🔹 Обмеження:**

- Потрібно підтримувати **постійне з'єднання**, що може бути проблемою при великій кількості клієнтів.
- **Не підходить для мультимедіа** (немає вбудованої оптимізації для відео/аудіо).
- Вимагає WebSocket-сумісного проксі (NGINX, Cloudflare).

---

## **2. Server-Sent Events (SSE) – Односторонній потік даних**

**🔹 Як працює:**  
SSE – це технологія, яка дозволяє серверу **потоком передавати оновлення клієнту через звичайне HTTP-з'єднання**. На відміну від WebSockets, SSE **не підтримує двосторонній зв'язок** – клієнт може отримувати дані, але не надсилати їх серверу через цей же канал.

**🔹 Основні особливості:**

- Використовує стандартні HTTP-з'єднання (`text/event-stream`).
- Автоматично **підтримує повторне з'єднання** (на відміну від WebSockets, де потрібно реалізовувати це вручну).
- Легко інтегрується у вже існуючі вебсервіси.

**🔹 Де використовуються:**  
✅ Стрічки новин, оновлення статусів  
✅ Біржові котирування  
✅ Системи моніторингу (логування, події)

**🔹 Обмеження:**

- Підтримує **лише односторонній зв’язок** (сервер → клієнт).
- Не працює поверх **HTTP/2**, що може обмежувати його використання у нових проєктах.
- Обмежена підтримка в деяких браузерах.

**🔹 Код для клієнта SSE:**

```javascript
const eventSource = new EventSource("/events");

eventSource.onmessage = function(event) {
    console.log("Отримані дані:", event.data);
};
```

---

## **3. gRPC – Оптимізований для комунікації між сервісами**

**🔹 Як працює:**  
gRPC – це високопродуктивний протокол на основі HTTP/2, який підтримує **стрімінгову передачу даних** і **автоматичну серіалізацію повідомлень** (часто використовується для мікросервісів).

**🔹 Основні особливості:**

- Використовує HTTP/2 для ефективного стрімінгу даних.
- Підтримує **двосторонній потік** (як WebSockets).

**🔹 Де використовується:**  
✅ Зв’язок між мікросервісами  
✅ Комунікація між мобільними додатками та сервером  
✅ Системи розподілених обчислень

**🔹 Обмеження:**

- Важко реалізувати у браузері (потрібен проксі).
- Менша гнучкість для вебзастосунків у порівнянні з WebSockets.

---

## **4. MQTT – Легковаговий протокол для IoT**

**🔹 Як працює:**  
MQTT (Message Queuing Telemetry Transport) – це **публікатор-підписник** протокол, оптимізований для пристроїв з обмеженими ресурсами (розумні датчики, IoT-гаджети).

**🔹 Основні особливості:**

- Дуже **ефективний і легкий** (менший розмір повідомлень, ніж у WebSockets).
- Працює поверх TCP або UDP.
- Використовує **брокер повідомлень** (наприклад, Eclipse Mosquitto), що дозволяє масштабувати систему.

**🔹 Де використовується:**  
✅ Розумний дім (IoT)  
✅ Датчики та телеметрія  
✅ Вбудовані системи (автомобілі, дрони)

**🔹 Обмеження:**

- Потрібен MQTT-брокер для передачі повідомлень.
- Не підходить для веббраузерів без спеціальних бібліотек.

---

## **5. WebRTC – Прямий зв’язок між клієнтами (P2P)**

**🔹 Як працює:**  
WebRTC (Web Real-Time Communication) дозволяє **безпосередньо передавати аудіо, відео та дані між клієнтами без серверного ретранслятора**. Це використовується у відеочатах, потоковій трансляції та іграх.

**🔹 Основні особливості:**

- Використовує **UDP** (нижча затримка, ніж у TCP).
- Підтримує **P2P-з'єднання**, що зменшує навантаження на сервери.
- Вбудований у більшість браузерів (`navigator.mediaDevices`).

**🔹 Де використовується:**  
✅ Відео- та аудіочати (Zoom, Google Meet)  
✅ Онлайн-ігри з прямою комунікацією  
✅ Поширення файлів між користувачами

**🔹 Обмеження:**

- Вимагає **STUN/TURN-серверів** для роботи за NAT.
- Не підходить для складних серверних додатків.

---

## **Порівняльна таблиця протоколів**

|Протокол|Двосторонній?|Стрімінг?|Оптимальний для|
|---|---|---|---|
|**WebSockets**|✅ Так|❌ Ні|Чати, біржі, онлайн-ігри|
|**SSE**|❌ Ні|✅ Так|Потоки даних, логування|
|**gRPC**|✅ Так|✅ Так|Зв'язок між сервісами|
|**MQTT**|✅ Так|❌ Ні|IoT, датчики|
|**WebRTC**|✅ Так|✅ Так|Відеочати, файлообмін|

---

## **Висновок**

WebSockets є хорошим вибором для **онлайн-чатів, фінансових додатків і інтерактивних панелей**, але вони не підходять для **відео/аудіо** (WebRTC) або **масштабованої комунікації між сервісами** (gRPC). MQTT ідеальний для IoT, а SSE – для серверного стрімінгу.


# **Практика**

### **Побудова ехо-сервера на Socket**

Ехо-сервер – це найпростіший приклад серверного застосунку на сокетах. Його принцип роботи полягає в тому, що сервер приймає повідомлення від клієнта та надсилає його назад без змін. Такий сервер дозволяє перевірити базову роботу сокетів і механізм двостороннього обміну даними.

Щоб реалізувати ехо-сервер на TCP у Python, спочатку потрібно створити серверний сокет, який працюватиме у режимі очікування клієнтів. Сервер створює сокет, прив’язується до порту, починає прослуховування та приймає вхідні з'єднання. Коли клієнт надсилає повідомлення, сервер читає його через `recv()`, а потім одразу відправляє назад за допомогою `send()`.

Ось базова реалізація ехо-сервера:

```python
import socket

HOST = '127.0.0.1'  # Локальний хост
PORT = 12345        # Порт, на якому працює сервер

# Створюємо сокет
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind((HOST, PORT))  # Прив'язуємо до адреси та порту
server_socket.listen()  # Починаємо слухати підключення

print(f"Сервер слухає на {HOST}:{PORT}")

while True:
    client_socket, client_address = server_socket.accept()  # Приймаємо підключення
    print(f"Підключено: {client_address}")

    while True:
        data = client_socket.recv(1024)  # Отримуємо дані
        if not data:
            break  # Якщо отримали пусте повідомлення – завершуємо обмін
        client_socket.sendall(data)  # Відправляємо ті ж дані назад

    client_socket.close()  # Закриваємо з'єднання
```

Коли сервер запущено, він чекає на підключення клієнтів. Кожне нове підключення створює окремий клієнтський сокет, який використовується для обміну повідомленнями з конкретним клієнтом. Якщо клієнт відправляє повідомлення, сервер отримує його та надсилає назад. Якщо клієнт закриває з'єднання, сервер завершує обробку цього клієнта та знову чекає на нові підключення.

Для тестування сервера можна створити клієнтський застосунок, який підключатиметься до нього та надсилатиме повідомлення. Ось простий клієнт на Python:

```python
import socket

HOST = '127.0.0.1'  # Адреса сервера
PORT = 12345        # Порт сервера

client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect((HOST, PORT))  # Підключаємося до сервера

while True:
    message = input("Введіть повідомлення (або 'exit' для виходу): ")
    if message.lower() == 'exit':
        break
    client_socket.sendall(message.encode())  # Відправляємо повідомлення
    data = client_socket.recv(1024)  # Отримуємо відповідь
    print(f"Сервер відповів: {data.decode()}")

client_socket.close()  # Закриваємо з'єднання
```

Після запуску сервера можна відкрити новий термінал і запустити клієнта. Клієнт дозволяє вводити повідомлення, відправляти їх на сервер і отримувати відповідь.

Цей простий ехо-сервер демонструє основи роботи з TCP-сокетами: створення, прив’язку до порту, прослуховування підключень, отримання та відправку даних. У наступному кроці ми розширимо цей код і реалізуємо простий чат-сервер, який дозволить одночасно спілкуватися кільком клієнтам.

### **Реалізація простого чат-сервера на сокетах**

Ехо-сервер є хорошою відправною точкою, але для створення повноцінного чату потрібно, щоб сервер міг обробляти кілька клієнтів одночасно. Якщо використовувати однопотокову модель, кожен клієнт блокуватиме роботу сервера, поки відбувається передача даних. Щоб уникнути цього, використовують багатопотокову або асинхронну модель. У цьому прикладі реалізуємо чат-сервер на основі потоків (`threading`), що дозволяє обробляти кожного клієнта в окремому потоці.

Основна ідея полягає в тому, що сервер має список підключених клієнтів і пересилає кожне отримане повідомлення всім іншим клієнтам. Кожен клієнт працює у власному потоці, що дозволяє серверу паралельно обробляти повідомлення.

Ось код сервера, який підтримує декілька клієнтів:

```python
import socket
import threading

HOST = '127.0.0.1'
PORT = 12345

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind((HOST, PORT))
server_socket.listen()

clients = []  # Список активних клієнтів

def handle_client(client_socket):
    while True:
        try:
            message = client_socket.recv(1024)
            if not message:
                break  # Вихід при втраті з'єднання
            broadcast(message, client_socket)
        except:
            break  # Вихід при помилці

    client_socket.close()
    clients.remove(client_socket)  # Видаляємо клієнта зі списку

def broadcast(message, sender_socket):
    for client in clients:
        if client != sender_socket:
            try:
                client.sendall(message)
            except:
                client.close()
                clients.remove(client)

print(f"Сервер запущений на {HOST}:{PORT}")

while True:
    client_socket, client_address = server_socket.accept()
    print(f"Підключився новий клієнт: {client_address}")
    clients.append(client_socket)
    thread = threading.Thread(target=handle_client, args=(client_socket,))
    thread.start()
```

Цей сервер виконує такі завдання:

1. Приймає підключення клієнтів та додає їх до загального списку.
2. Запускає окремий потік для кожного клієнта, який постійно слухає вхідні повідомлення.
3. Пересилає отримане повідомлення всім іншим клієнтам.
4. При розриві з'єднання прибирає клієнта зі списку.

Тепер реалізуємо клієнт, який дозволятиме користувачам підключатися до сервера та обмінюватися повідомленнями:

```python
import socket
import threading

HOST = '127.0.0.1'
PORT = 12345

client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect((HOST, PORT))

def receive_messages():
    while True:
        try:
            message = client_socket.recv(1024).decode()
            if not message:
                break
            print("\n" + message)
        except:
            break

receive_thread = threading.Thread(target=receive_messages)
receive_thread.start()

while True:
    message = input()
    if message.lower() == 'exit':
        break
    client_socket.sendall(message.encode())

client_socket.close()
```

Клієнт працює наступним чином:

1. Підключається до сервера та запускає окремий потік для отримання повідомлень.
2. Відправляє введені користувачем повідомлення на сервер.
3. Виводить отримані повідомлення в консоль.
4. Завершує роботу при введенні `exit`.

Цей простий чат-сервер дозволяє користувачам обмінюватися повідомленнями у спільному каналі. Він працює на TCP і використовує потоки для одночасного обслуговування кількох клієнтів. Наступним кроком розглянемо WebSockets, які дозволяють створювати більш ефективні та зручні для браузера чати з постійним з'єднанням.

### **Реальний час комунікацій – протокол WebSockets**

Класичні TCP-сокети добре підходять для створення чат-серверів, але вони мають певні недоліки, особливо коли йдеться про роботу у вебсередовищі. HTTP-протокол, який використовується у веббраузерах, працює за моделлю "запит-відповідь", що ускладнює реалізацію постійного двостороннього з'єднання. Для вирішення цієї проблеми існує WebSockets – сучасний протокол, що дозволяє встановлювати стійке з'єднання між клієнтом і сервером.

WebSockets працює поверх TCP і дозволяє серверу та клієнту обмінюватися повідомленнями у будь-який момент часу без необхідності постійно відкривати нові з'єднання. Це суттєво зменшує накладні витрати та підходить для чатів, онлайн-ігор, біржових систем, а також будь-яких застосунків, що потребують оновлення в реальному часі.

Ключовий момент роботи WebSockets – це **рукостискання (handshake)**, яке відбувається через звичайний HTTP-запит. Під час ініціалізації клієнт надсилає серверу спеціальний `Upgrade`-запит, який запитує зміну протоколу з HTTP на WebSocket. Якщо сервер підтримує WebSockets, він підтверджує перехід, після чого встановлюється постійне двостороннє з'єднання.

Ось як виглядає типовий HTTP-запит для встановлення WebSocket-з'єднання:

```
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9YZrd92==  
Sec-WebSocket-Version: 13
```

Сервер, який підтримує WebSockets, відповідає наступним чином:

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
```

Після цього клієнт і сервер можуть обмінюватися повідомленнями без додаткових HTTP-запитів. На відміну від стандартних HTTP-з'єднань, WebSockets підтримують **події**, які дозволяють серверу відправляти дані клієнту, навіть якщо той не робив запиту. Це критично важливо для чат-систем, стрімінгу даних або оновлення інформації в реальному часі.

Ще однією важливою перевагою WebSockets є зменшення накладних витрат у порівнянні з HTTP-запитами. У HTTP кожен запит вимагає встановлення нового з'єднання, а в WebSockets використовується одне з'єднання, що залишається відкритим протягом усього сеансу. Це дозволяє суттєво зменшити затримки та покращити продуктивність.

Завдяки вбудованій підтримці WebSockets у браузерах клієнти можуть легко підключатися до WebSocket-серверів через JavaScript API. Використовуючи об'єкт `WebSocket`, можна відправляти та отримувати повідомлення безпосередньо у браузері, що спрощує реалізацію чатів та інтерактивних додатків.

Наступним кроком реалізуємо простий WebSocket-сервер на FastAPI, щоб показати, як працює двосторонній обмін даними у реальному часі.

### **WebSockets: Робота з браузером та постійне з'єднання**

WebSockets є частиною сучасних вебтехнологій і підтримуються більшістю браузерів. Вони дозволяють клієнту та серверу встановити постійне з'єднання, що дає змогу передавати дані без необхідності повторних HTTP-запитів. Це робить WebSockets ідеальними для додатків, що потребують оновлення в реальному часі, зокрема чатів, біржових платформ, онлайн-ігор та потокової аналітики.

На відміну від стандартного HTTP-запиту, де клієнт відправляє запит і очікує на відповідь, WebSockets дозволяють передавати повідомлення в обох напрямках у будь-який момент часу. Це усуває проблему постійних запитів (`polling`) та значно зменшує затримки між повідомленнями.

Щоб встановити WebSocket-з'єднання у браузері, достатньо скористатися стандартним JavaScript API. Для цього створюється об'єкт `WebSocket`, який ініціює з'єднання з сервером і дозволяє відправляти та отримувати дані. Ось як виглядає мінімальний код для підключення до WebSocket-сервера:

```javascript
const socket = new WebSocket("ws://localhost:8000/ws");

socket.onopen = function() {
    console.log("З'єднання встановлено");
    socket.send("Привіт, сервере!");
};

socket.onmessage = function(event) {
    console.log("Отримано повідомлення:", event.data);
};

socket.onclose = function() {
    console.log("З'єднання закрито");
};
```

У цьому прикладі створюється WebSocket-з'єднання з сервером за адресою `ws://localhost:8000/ws`. Подія `onopen` спрацьовує після успішного підключення, і клієнт відправляє перше повідомлення. Коли сервер відповідає, `onmessage` обробляє отримані дані та виводить їх у консоль. Подія `onclose` виконується при розриві з'єднання.

На серверному боці WebSocket-з'єднання підтримується у FastAPI через `WebSocket`-ендпоінт. FastAPI має вбудовану підтримку WebSockets, що дозволяє легко реалізувати сервер для роботи у реальному часі.

Розглянемо просту реалізацію WebSocket-сервера на FastAPI:

```python
from fastapi import FastAPI, WebSocket
from fastapi.responses import HTMLResponse

app = FastAPI()

@app.get("/")
async def get():
    return HTMLResponse("<h1>WebSocket сервер працює!</h1>")

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        print(f"Отримано: {data}")
        await websocket.send_text(f"Сервер відповідає: {data}")
```

Коли клієнт підключається до `/ws`, сервер приймає WebSocket-з'єднання через `await websocket.accept()`. Після цього сервер постійно очікує на нові повідомлення від клієнта через `await websocket.receive_text()`. Отримані дані сервер відправляє назад клієнту, і це можна побачити у консолі браузера.

Якщо тепер у браузері запустити JavaScript-код з попереднього прикладу, то можна побачити, як браузер підключається до сервера, надсилає повідомлення і отримує відповідь у реальному часі.

На цьому етапі ми маємо базовий WebSocket-сервер, який може встановлювати з'єднання та обмінюватися повідомленнями з клієнтами. Наступним кроком буде реалізація чату на основі WebSockets, що дозволить одночасно взаємодіяти кільком клієнтам.

### **Чат на WebSockets: Реалізація на FastAPI**

Тепер, коли ми розібралися з основами WebSockets, побудуємо простий багатокористувацький чат. На відміну від попереднього прикладу, де сервер обробляв лише одне підключення, тепер потрібно дозволити кільком клієнтам взаємодіяти між собою.

Головною особливістю такого чату буде список активних підключень. Коли один клієнт надсилає повідомлення, сервер має переслати його всім іншим учасникам. Це реалізується за допомогою списку `active_connections`, у якому зберігатимуться WebSocket-з'єднання всіх користувачів.

Ось код сервера:

```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect

app = FastAPI()

class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.broadcast(f"Користувач: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket)
```

У цьому коді використовується клас `ConnectionManager`, який керує списком активних підключень. Коли новий клієнт підключається, він додається до списку через `connect()`. Якщо клієнт надсилає повідомлення, воно передається всім підключеним клієнтам через `broadcast()`. Якщо з'єднання розривається, клієнт видаляється зі списку.

### **Клієнтський JavaScript-код для чату**

Щоб перевірити роботу чату, створимо простий HTML-файл, який дозволятиме користувачам вводити повідомлення та бачити отримані відповіді:

```html
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Чат на WebSockets</title>
</head>
<body>
    <h1>Простий чат</h1>
    <input type="text" id="messageInput" placeholder="Введіть повідомлення">
    <button onclick="sendMessage()">Надіслати</button>
    <ul id="messages"></ul>

    <script>
        const socket = new WebSocket("ws://localhost:8000/ws");

        socket.onmessage = function(event) {
            const msgList = document.getElementById("messages");
            const msgItem = document.createElement("li");
            msgItem.textContent = event.data;
            msgList.appendChild(msgItem);
        };

        function sendMessage() {
            const input = document.getElementById("messageInput");
            socket.send(input.value);
            input.value = "";
        }
    </script>
</body>
</html>
```

### **Як це працює**

1. Коли сторінка завантажується, браузер відкриває WebSocket-з'єднання з сервером.
2. Користувач вводить текст у поле та натискає кнопку "Надіслати".
3. Повідомлення передається на сервер через `socket.send(input.value)`.
4. Сервер отримує повідомлення, пересилає його всім клієнтам через `broadcast()`, у тому числі й відправнику.
5. Усі клієнти, що підключені до сервера, отримують повідомлення та додають його до списку повідомлень у браузері.

### **Перевірка роботи**

1. Запустити сервер FastAPI (`uvicorn filename:app --reload`).
2. Відкрити HTML-сторінку у кількох вкладках браузера або різних пристроях.
3. Надсилати повідомлення у полі вводу та бачити, як вони з'являються у всіх клієнтів.

Цей чат-сервер є мінімальною, але повністю функціональною реалізацією. Він демонструє, як WebSockets можуть підтримувати реальний час комунікацій без потреби у сторонніх технологіях, таких як Redis.

