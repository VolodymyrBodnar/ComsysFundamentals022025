### **1. Вступ

Асинхронне програмування – це техніка, яка дозволяє писати код, що може виконувати кілька задач одночасно, не блокуючи головний потік виконання. Спочатку потрібно зрозуміти, чому воно взагалі існує і які проблеми вирішує.

Уявімо, що ми пишемо програму для обробки запитів до API або завантаження файлів із мережі. Якщо використовувати звичайний синхронний код, кожен запит буде блокувати виконання наступного коду до отримання відповіді. Наприклад, якщо потрібно зробити три запити до API, кожен із яких триває 2 секунди, загальний час виконання буде не менше 6 секунд.

Приклад синхронного коду:

```python
import time

def fetch_data():
    print("Запит до сервера...")
    time.sleep(2)
    print("Отримано відповідь!")

print("Початок")
fetch_data()
fetch_data()
fetch_data()
print("Кінець")
```

Цей код спочатку виконає перший запит, потім другий і третій, чекаючи кожного разу по 2 секунди. У підсумку отримаємо затримку в 6 секунд. Проблема в тому, що під час очікування відповідей процесор простоює, хоча міг би займатися іншими корисними завданнями.

У випадку асинхронного програмування можна працювати з такими запитами одночасно. Головна ідея – не блокувати виконання коду там, де це не потрібно. У Python це досягається за допомогою ключових слів `async` і `await`, а також спеціального механізму – **event loop**.

Перед тим як зануритися в деталі, потрібно розглянути три основні підходи до конкурентності в програмуванні:

1. **Мультипроцесинг**. Коли програма створює окремі процеси для виконання задач, кожен з яких має власну пам’ять і ресурси. Це підхід корисний для важких обчислень, але він потребує великих витрат на створення процесів.
2. **Багатопоточність**. Коли в одному процесі створюються кілька потоків, які можуть працювати паралельно. Проблема в тому, що через GIL у Python багатопоточність не дає справжньої паралельності для CPU-bound задач, хоча корисна для роботи з мережею.
3. **Асинхронність**. Використання механізму, який дозволяє виконувати кілька операцій одночасно без блокування основного потоку. Тут немає справжньої паралельності, але завдання розподіляються ефективніше.

Асинхронне програмування особливо добре працює в задачах, пов’язаних із введенням-виведенням (I/O-bound), таких як робота з мережею, читання файлів або баз даних. Його не варто плутати з багатопоточністю або мультипроцесингом, оскільки воно працює за іншим принципом.

**Замість того щоб просто говорити, що асинхронний код працює "одночасно", коректніше сказати, що він змінює порядок виконання таким чином, щоб під час очікування не було простоїв. Всі асинхронні операції виконуються в межах одного потоку, використовуючи механізм event loop, який ми розглянемо детальніше в наступному розділі.**

Асинхронне програмування стало особливо популярним у веб-розробці завдяки **Node.js**. До появи Node.js більшість веб-серверів працювали на основі блокуючих моделей, де кожен запит займав окремий потік або процес. Це призводило до того, що сервери споживали багато пам’яті та мали проблеми з масштабуванням. Node.js запропонував інший підхід – **івент-орієнтовану, неблокуючу модель вводу-виводу**. Це дозволило писати серверний код, який міг одночасно обробляти тисячі з’єднань без необхідності створювати окремий потік для кожного запиту.

Головна ідея Node.js – використання **Event Loop** для обробки подій, завдяки чому код міг запускати запити до бази даних, файлової системи або мережі, не чекаючи їхнього завершення. Це зробило можливим створення швидких і ефективних веб-додатків, особливо для реального часу, таких як чати, стрімінгові платформи або API-сервіси з високим навантаженням. Концепції, які з’явилися в Node.js, швидко поширилися на інші мови програмування, зокрема Python.

У Python асинхронне програмування активно використовується в кількох важливих бібліотеках і фреймворках. Найпопулярніші серед них:

- **FastAPI** – один із найшвидших веб-фреймворків у Python, побудований на `asyncio`, який дозволяє писати асинхронні API. Завдяки асинхронному виконанню запитів він набагато продуктивніший, ніж традиційний Flask або Django.
- **Starlette** – легкий веб-фреймворк, який є основою FastAPI та використовує асинхронність для обробки HTTP-запитів.
- **Aiohttp** – фреймворк для створення асинхронних веб-серверів і клієнтів, який дозволяє писати неблокуючі HTTP-запити.
- **Tornado** – ще один асинхронний веб-фреймворк, який з’явився ще до `asyncio` і все ще використовується в деяких проєктах.
- **Django Channels** – доповнення до Django, яке додає підтримку WebSockets та інших асинхронних механізмів.

Завдяки цим інструментам Python став конкурентоспроможним у світі асинхронного веб-програмування. В наступному розділі ми глибше розглянемо, як працює **Event Loop**, оскільки це ключова концепція для розуміння того, як функціонує асинхронний код.

### **2. Основні концепти: Event Loop**

**Event Loop** – це фундаментальна концепція асинхронного програмування, яка походить із світу операційних систем та мережевого програмування. У традиційних програмах, коли процес виконує завдання, він працює в послідовному порядку: один виклик за іншим, поки всі задачі не будуть виконані. Якщо одна з операцій вимагає очікування (наприклад, отримання даних із сервера або читання з файлу), весь процес "завмирає", поки ця операція не завершиться. Це називається **блокуючим виконанням**, і воно є типовим для імперативного програмування.

Інший підхід полягає в тому, щоб використовувати **подієво-орієнтовану модель**, коли програма не чекає завершення операції, а замість цього **реєструє подію** та передає її в Event Loop. Це дозволяє коду виконувати інші завдання, поки очікувана операція триває у фоновому режимі. Коли подія завершується, Event Loop повертається до неї та відновлює її виконання.

З точки зору програмування, можна сказати, що Event Loop працює як **диспетчер задач**. Він стежить за всіма асинхронними викликами, додає їх у чергу виконання та поетапно запускає їх. Коли одна корутина чекає на завершення операції, Event Loop переключається на іншу, не витрачаючи ресурси процесора даремно. Завдяки цьому один і той самий потік може ефективно керувати тисячами одночасних запитів.

### **Порівняння з традиційною багатопотоковістю**

У традиційній багатопотоковості для вирішення проблеми блокування використовують **потоки (threads)**. У такій моделі кожне завдання може виконуватися в окремому потоці, і операційна система перемикає контекст між потоками. Проблема в тому, що створення великої кількості потоків витрачає багато пам’яті, а перемикання між потоками займає додатковий час. Крім того, якщо потоки звертаються до однієї області пам’яті, виникають **проблеми потокобезпеки**, і потрібно використовувати блокування (mutex), що ще більше ускладнює програмування.

На відміну від цього, асинхронний підхід у Python не використовує справжню багатопоточність. Усі асинхронні задачі виконуються в **одному потоці**, але вони ефективно перемикаються між собою, використовуючи **кооперативну багатозадачність**. Це означає, що завдання добровільно передають керування назад в Event Loop, коли виконують `await`. Завдяки цьому асинхронний код можна масштабувати краще, ніж багатопотоковий.

### **Як Event Loop працює під капотом**

![[Pasted image 20250304185915.png]]
Коли ми запускаємо `asyncio.run()`, Python створює Event Loop і починає виконувати всі зареєстровані корутини. У цьому процесі важливу роль відіграють три ключові компоненти:

1. **Task Queue (черга завдань)** – місце, де зберігаються всі зареєстровані корутини.
2. **Selector (система спостереження)** – механізм, який очікує на завершення операцій вводу-виводу, щоб знати, коли можна повернутися до виконання корутини.
3. **Scheduler (планувальник)** – логіка, яка вирішує, яке завдання потрібно виконати наступним.

Якщо подивитися на Event Loop із точки зору операційної системи, він працює за схожим принципом із `epoll` в Linux або `select` у Windows, де процес може чекати на кілька мережевих або файлових подій одночасно. Це дозволяє йому **реагувати** на події, а не блокувати виконання під час очікування.

### **Головне обмеження Event Loop**

Незважаючи на всі переваги, важливо розуміти, що асинхронне програмування в Python **не вирішує проблему обчислювально важких задач (CPU-bound)**. Якщо задача вимагає тривалих обчислень, наприклад, обробки великих обсягів даних, вона **заблокує Event Loop** і не дасть іншим завданням виконуватися. У таких випадках краще використовувати **мультипроцесинг**, щоб розподілити роботу між кількома ядрами процесора.

#### **Як працює Event Loop у Python**

Python використовує вбудовану бібліотеку `asyncio`, яка реалізує механізм Event Loop. Головна ідея цього механізму – обробка асинхронних завдань у вигляді **подій**. Він працює за принципом:

1. Додає асинхронні задачі в чергу виконання.
2. Вибирає перше доступне завдання і запускає його до моменту, коли воно повинне **чекати** чогось (наприклад, відповіді з сервера).
3. Як тільки завдання переходить у стан очікування, Event Loop перемикається на інше завдання.
4. Коли очікуване завдання завершується (наприклад, отримано відповідь від сервера), Event Loop повертається до нього і виконує далі.

Щоб побачити це на практиці, розглянемо простий приклад.

```python
import asyncio

async def task(name, delay):
    print(f"Завдання {name} починається")
    await asyncio.sleep(delay)
    print(f"Завдання {name} завершене")

async def main():
    await asyncio.gather(task("A", 2), task("B", 1), task("C", 3))

asyncio.run(main())
```

У цьому коді ми створюємо три асинхронні функції, які чекають різну кількість часу (`asyncio.sleep` – це асинхронна версія `time.sleep`). Завдяки `asyncio.gather()` ці функції виконуються **одночасно**, хоча насправді жодна з них не запускається в окремому потоці.

Результат роботи покаже, що всі три завдання стартують відразу, але завершуються в порядку їхньої тривалості:

```
Завдання A починається  
Завдання B починається  
Завдання C починається  
Завдання B завершене  
Завдання A завершене  
Завдання C завершене  
```

Якби ми використовували звичайні синхронні `time.sleep()`, код виконувався б послідовно, витративши 6 секунд. Але завдяки Event Loop три корутини змогли змінювати порядок виконання так, щоб не блокувати одна одну.

#### **Як Event Loop взаємодіє з корутинами**

Основні дії, які виконує Event Loop:

- **Реєструє корутини** та додає їх у чергу завдань.
- **Запускає корутину** і виконує її код до моменту, коли вона зупиняється (`await`).
- **Переключається на іншу корутину**, якщо поточна чекає на завершення зовнішньої операції (наприклад, завантаження даних з інтернету).
- **Повертається до корутин**, як тільки зовнішня операція завершилася.

Щоб глибше зрозуміти, як працює Event Loop, можна розглянути його реалізацію на псевдокоді:

```python
queue = []

def event_loop():
    while queue:
        task = queue.pop(0)  # Беремо перше завдання
        try:
            next(task)  # Виконуємо його до першого `await`
            queue.append(task)  # Якщо не завершилось, повертаємо в чергу
        except StopIteration:
            pass  # Завдання виконане повністю, його прибираємо з черги
```

Це спрощена модель Event Loop. Він бере задачу, запускає її, доки вона не дійде до `await`, потім переключається на інше завдання, а коли воно завершується, повертається до першого. Таким чином, код працює ефективно, не витрачаючи час на очікування.

#### **Що буде, якщо викликати корутину без await?**

Однією з найпоширеніших помилок початківців є виклик асинхронної функції без `await`. Наприклад:

```python
async def example():
    return 42

result = example()  # Помилка! Це корутина, а не результат
print(result)  # <coroutine object example at 0x...>
```

У цьому випадку `example()` просто повертає корутину, але не виконує її. Щоб запустити, потрібно або використати `await`, або перетворити її в `Task`:

```python
async def main():
    result = await example()
    print(result)

asyncio.run(main())
```

Якщо просто викликати корутину без `await`, вона не буде виконана, і програма не отримає очікуваний результат. Це одна з причин, чому початківці часто плутаються, працюючи з `async` і `await`.

#### **Чому Event Loop працює в одному потоці?**

У Python асинхронне програмування **не забезпечує** справжньої паралельності, тому що всі корутини виконуються в одному потоці. Це зроблено для того, щоб уникнути проблем із потокобезпекою та доступом до змінних у пам’яті. Асинхронний код працює швидко лише в задачах, пов’язаних із введенням-виведенням (I/O-bound), де головне завдання – правильно організувати порядок виконання.

Якщо потрібно виконувати важкі обчислення, краще використовувати `multiprocessing`, оскільки асинхронність тут не допоможе. Наприклад, обчислення великої кількості факторіалів краще передати в окремі процеси, ніж намагатися запускати їх через Event Loop.


### **3. Корутини

Корутину можна уявити як **функцію, яка може призупиняти своє виконання і повертатися до нього пізніше**.

Корутини можна уявити як еволюцію генераторів, які дозволяють не лише **повертати проміжні значення**, але й **чекати на виконання асинхронних операцій**. Це дозволяє програмі ефективно керувати часом виконання, не блокуючи основний потік. На фундаментальному рівні Python працює з **кооперативною багатозадачністю**, де корутини добровільно віддають керування, коли зустрічають `await`. Це ключова відмінність від традиційної багатопотоковості, де операційна система примусово перемикає потоки.

Щоб зрозуміти, як працює корутинний підхід, уявімо ситуацію у фаст-фуд ресторані, наприклад, у **McDonald's**. Раніше, коли замовлення приймалися виключно через касирів, процес був **послідовним**: кожен клієнт підходив до каси, робив замовлення, чекав на його приготування і лише тоді забирав свою їжу. Це нагадує **синхронне програмування**: кожне замовлення виконується одне за одним, і наступний клієнт не може почати процес, поки попередній не отримає своє замовлення.

Сучасні McDonald's використовують **термінали самообслуговування**. Тепер клієнти можуть робити замовлення незалежно від інших, без блокування процесу. Як тільки замовлення оформлене, воно з'являється на **екрані кухні**, і кухарі можуть паралельно готувати кілька страв. Коли страва готова, її номер висвічується на екрані, і клієнт може забрати її, навіть якщо його замовлення було оформлене пізніше за інші. Це працює аналогічно до **асинхронного програмування**, де всі запити передаються в Event Loop, виконуються незалежно, а коли результат готовий, він повертається користувачеві.

Якщо застосувати цю аналогію до Python, то:

- **Клієнт** – це запущена корутина.
- **Каса** – це блокуючий виклик (синхронний код), коли кожен мусить чекати.
- **Термінал самообслуговування** – це асинхронний виклик, коли замовлення одразу передається на виконання, а клієнт може займатися іншими справами.
- **Екран кухні** – це механізм `await`, який повертає результат, коли він готовий.

У наступному розділі ми розглянемо **ф’ючерси (Futures) та завдання (Tasks)**, які дозволяють ще гнучкіше керувати виконанням асинхронних процесів.

Щоб зрозуміти, як це працює, спочатку варто порівняти звичайні функції та генератори, а потім перейти до корутин.

### **Функції, генератори та корутини**

Звичайна функція виконується **від початку до кінця** і не може бути перервана або відновлена. Наприклад:

```python
def hello():
    print("Привіт")
    return "Світ"

print(hello())
```

Функція `hello()` просто повертає значення, після чого її виконання завершується. Але що, якщо ми хочемо, щоб функція працювала поступово, призупинялася і повертала керування програмі? Для цього існують **генератори**.

Генератор працює за допомогою `yield`, який дозволяє функції **призупиняти** своє виконання і відновлювати його пізніше. Наприклад:

```python
def generator():
    print("Перше виконання")
    yield 1
    print("Друге виконання")
    yield 2

gen = generator()
print(next(gen))  # Виведе "Перше виконання" і 1
print(next(gen))  # Виведе "Друге виконання" і 2
```

Кожного разу, коли викликається `next(gen)`, генератор виконує код до наступного `yield`, після чого **зупиняється**, зберігаючи свій стан.

Корутину можна уявити як розширену версію генератора, яка може не лише **повертати значення**, але й **очікувати на результат асинхронної операції**. Це дозволяє ефективно працювати з асинхронними запитами, такими як очікування відповіді від сервера або читання файлів.

### **Оголошення та виконання корутин**

У Python корутиною є функція, яка оголошується за допомогою `async def`. Вона не виконується відразу при виклику, а повертає спеціальний об’єкт `coroutine`.

```python
import asyncio

async def my_coroutine():
    print("Корутинний код")
    await asyncio.sleep(1)
    print("Завершено")

print(my_coroutine())  # Виведе <coroutine object my_coroutine at ...>
```

Щоб виконати корутину, її потрібно **"запустити"** в Event Loop, використовуючи `await` або `asyncio.run()`:

```python
asyncio.run(my_coroutine())
```

Ключове слово `await` дозволяє корутині **призупинити** виконання, щоб дочекатися результату іншої асинхронної операції. Наприклад, якщо корутина чекає 1 секунду (`await asyncio.sleep(1)`), вона не блокує виконання коду, а дозволяє Event Loop перейти до іншого завдання.

### **Чому корутина не є звичайною функцією?**

На відміну від звичайних функцій, корутина **не повертає значення одразу**. Наприклад, розглянемо наступний код:

```python
async def add(x, y):
    return x + y

result = add(2, 3)
print(result)  # Виведе <coroutine object add at ...>
```

Якщо викликати корутину без `await`, вона не виконається і просто поверне об’єкт `coroutine`. Щоб отримати результат, потрібно використати `await`:

```python
async def main():
    result = await add(2, 3)
    print(result)  # Виведе 5

asyncio.run(main())
```

Це важливий момент, який часто плутають початківці.

### **Як корутини виконуються в Event Loop?**

Розглянемо приклад кількох корутин, які запускаються одночасно:

```python
import asyncio

async def task(name, delay):
    print(f"{name} почав виконання")
    await asyncio.sleep(delay)
    print(f"{name} завершив виконання")

async def main():
    await asyncio.gather(
        task("Завдання 1", 3),
        task("Завдання 2", 1),
        task("Завдання 3", 2)
    )

asyncio.run(main())
```

Цей код працює наступним чином:

1. Запускається три корутини (`task`), які мають різні затримки.
2. Завдяки `await`, вони не блокують одна одну, а виконуються паралельно.
3. `asyncio.gather()` дозволяє Event Loop керувати всіма корутинами одночасно.

В результаті вивід буде таким:

```
Завдання 1 почав виконання  
Завдання 2 почав виконання  
Завдання 3 почав виконання  
Завдання 2 завершив виконання  
Завдання 3 завершив виконання  
Завдання 1 завершив виконання  
```

Корутина `task("Завдання 2", 1)` завершується першою, бо її затримка найменша. Це підтверджує, що корутини виконуються **не послідовно, а залежно від подій**.

### **Зв’язок корутин і Task**

Коли ми використовуємо `await`, ми **очікуємо завершення корутини** перед тим, як продовжити виконання. Але інколи потрібно запустити корутину у фоновому режимі, не чекаючи її завершення одразу. Для цього існує `asyncio.create_task()`, який створює об'єкт `Task`:

```python
async def background_task():
    await asyncio.sleep(2)
    print("Фонова задача завершена")

async def main():
    asyncio.create_task(background_task())  # Запускаємо у фоновому режимі
    print("Основна частина коду")
    await asyncio.sleep(3)  # Чекаємо трохи довше, щоб фонова задача завершилася

asyncio.run(main())
```

Завдяки `asyncio.create_task()` фонова корутина виконується незалежно від основного коду. Якщо не викликати `await` для цієї корутини, вона просто буде працювати у фоновому режимі, доки Event Loop не завершиться.

### **Ключові помилки початківців**

1. Викликати корутину без `await`, що призводить до повернення об’єкта `coroutine`, а не виконання коду.
2. Використовувати `asyncio.run()` всередині іншої асинхронної функції, що викликає помилку `RuntimeError: This event loop is already running`.
3. Використовувати `time.sleep()` замість `await asyncio.sleep()`, що блокує виконання всього Event Loop.
4. Забувати створювати `Task`, коли потрібно запустити асинхронну корутину у фоновому режимі.

### **4. Ф’ючерси, Завдання та Обробка Винятків 

Асинхронне програмування в Python використовує не лише корутини, але й спеціальні об’єкти для керування їх виконанням. Найважливіші з них – **Futures** та **Tasks**.

### **Ф’ючерси (Futures) – обіцянки майбутнього результату**

Об’єкт `Future` представляє **результат операції, який буде доступний у майбутньому**. Це як замовлення у McDonald's: ви платите за їжу, отримуєте чек (який підтверджує, що їжа готується), а коли замовлення готове – вам його видають.

У Python `asyncio.Future` використовується рідко напряму, оскільки для зручності розробники працюють із `asyncio.Task`, який є надбудовою над `Future`. Але для розуміння принципу роботи важливо знати, що **Task – це розширена версія Future, яка може виконувати корутину у фоновому режимі**.

Розглянемо простий приклад `Future`:

```python
import asyncio

async def set_future(future):
    await asyncio.sleep(2)
    future.set_result("Дані отримано")

async def main():
    loop = asyncio.get_running_loop()
    future = loop.create_future()
    asyncio.create_task(set_future(future))
    print("Чекаємо на результат...")
    result = await future
    print(result)

asyncio.run(main())
```

Коли виконується `set_future(future)`, воно спочатку чекає 2 секунди (`await asyncio.sleep(2)`) і потім викликає `future.set_result("Дані отримано")`. В цей момент майбутнє значення з’являється, і всі, хто очікує на `await future`, отримують його.

### **Tasks – запущені корутини**

Task – це спеціальний об’єкт, який дозволяє **запускати корутину у фоновому режимі** без необхідності чекати на її завершення одразу.

Розглянемо приклад:

```python
import asyncio

async def background_task():
    await asyncio.sleep(3)
    print("Фонова задача завершена")

async def main():
    task = asyncio.create_task(background_task())  # Запускаємо у фоновому режимі
    print("Основна частина коду виконується")
    await asyncio.sleep(1)  # Головний потік не чекає завершення background_task
    print("Головна частина коду завершена")
    await task  # Очікуємо завершення фонової задачі перед виходом

asyncio.run(main())
```

У цьому випадку `background_task()` запускається, але **головний потік не чекає** її завершення одразу. Завдяки `asyncio.create_task()` ми можемо запустити корутину у фоновому режимі та продовжити виконання основного коду.

Вивід буде таким:

```
Основна частина коду виконується  
Головна частина коду завершена  
Фонова задача завершена  
```

Якщо не викликати `await task` у кінці, то фонове завдання **може бути перервано**, якщо програма завершиться раніше, ніж воно виконається.

### **Різниця між Task і Future**

- `Future` просто **зберігає значення**, яке з’явиться в майбутньому (аналог Promise у JavaScript).
- `Task` **виконує корутину** і повертає `Future`, коли результат готовий.

### **Обробка винятків у асинхронному коді**

Одна з найпоширеніших помилок у асинхронному коді – неправильна обробка помилок у корутинах. Якщо у звичайному коді можна просто використати `try-except`, то у випадку `asyncio.create_task()` винятки можуть "загубитися", якщо їх не обробити правильно.

Наприклад, ось код, де виняток **не обробляється правильно**:

```python
import asyncio

async def faulty_task():
    await asyncio.sleep(2)
    raise ValueError("Щось пішло не так!")

async def main():
    task = asyncio.create_task(faulty_task())  # Запускаємо у фоновому режимі
    await asyncio.sleep(3)  # Головний потік триває
    print("Кінець програми")

asyncio.run(main())
```

У цьому випадку **виняток у `faulty_task` не буде помічений**. Якщо запускати цей код, помилка з’явиться в логах, але програма продовжить роботу, ніби нічого не сталося.

Щоб **правильно** обробити виняток у Task, потрібно явно відловлювати його:

```python
async def faulty_task():
    try:
        await asyncio.sleep(2)
        raise ValueError("Щось пішло не так!")
    except Exception as e:
        print(f"Помилка: {e}")

async def main():
    task = asyncio.create_task(faulty_task())  # Запускаємо у фоновому режимі
    await asyncio.sleep(3)  # Головний потік триває
    print("Кінець програми")

asyncio.run(main())
```

У цьому випадку помилка не зникне, а буде оброблена коректно.

### **Обробка помилок у декількох задачах**

Якщо використовується `asyncio.gather()`, то обробляти помилки потрібно трохи інакше:

```python
async def failing_task():
    await asyncio.sleep(1)
    raise RuntimeError("Помилка у завданні")

async def successful_task():
    await asyncio.sleep(2)
    return "Успіх!"

async def main():
    try:
        results = await asyncio.gather(failing_task(), successful_task(), return_exceptions=True)
        print(results)  # Виведе список з результатами всіх задач, включаючи винятки
    except Exception as e:
        print(f"Помилка: {e}")

asyncio.run(main())
```

У цьому випадку використання `return_exceptions=True` дозволяє зібрати всі результати, навіть якщо деякі з них викликають помилки. Це особливо корисно, якщо потрібно виконати кілька незалежних задач і не припиняти виконання через одну помилку.

### **5. Практичне використання асинхронності: HTTP-запити та FastAPI **

Асинхронне програмування найбільш корисне у ситуаціях, коли потрібно виконувати багато **мережевих запитів** одночасно. Це можуть бути запити до API, веб-скрейпінг, робота з мікросервісами тощо.

У цьому розділі розглянемо:

1. Як асинхронні HTTP-запити працюють в `aiohttp`.
2. Як використовувати асинхронність у FastAPI для створення ефективного веб-сервера.

---

### **Асинхронні HTTP-запити з `aiohttp`**

Припустимо, потрібно отримати дані з API кілька разів. Якщо робити це синхронно, кожен запит чекатиме завершення попереднього, що займе багато часу.

Асинхронний варіант дозволяє виконати всі запити одночасно:

```python
import aiohttp
import asyncio

async def fetch_data(session, url):
    async with session.get(url) as response:
        return await response.json()

async def main():
        urls = [f"https://jsonplaceholder.typicode.com/todos/{i}" for i in range(1,6)]
    
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_data(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        print(f"Запит {i+1}: {result}")

asyncio.run(main())
```

Тут всі 5 запитів до API виконуються **одночасно**, а не по черзі. Використання `asyncio.gather(*tasks)` дозволяє зекономити час, оскільки запити не блокують один одного.

---

### **Асинхронний веб-сервер з FastAPI**

FastAPI – це асинхронний веб-фреймворк, який використовує `asyncio` та `Starlette`. Його головна перевага – **швидкість і підтримка асинхронних запитів**.

Створимо простий FastAPI-сервер, який матиме кілька асинхронних маршрутів.

#### **1. Встановлення FastAPI та Uvicorn**

Перед тим як писати код, потрібно встановити необхідні бібліотеки:

```bash
pip install fastapi uvicorn
```

#### **2. Написання FastAPI-додатку**

```python
from fastapi import FastAPI
import asyncio

app = FastAPI()

@app.get("/")
async def home():
    return {"message": "Це головна сторінка"}

@app.get("/slow")
async def slow_response():
    await asyncio.sleep(3)  # Симуляція довготривалого запиту
    return {"message": "Відповідь через 3 секунди"}

@app.get("/parallel")
async def parallel_requests():
    async def fake_io_task(name, delay):
        await asyncio.sleep(delay)
        return {name: f"Готово через {delay} секунд"}

    task1 = fake_io_task("Завдання 1", 2)
    task2 = fake_io_task("Завдання 2", 1)
    task3 = fake_io_task("Завдання 3", 3)

    results = await asyncio.gather(task1, task2, task3)
    return {"results": results}
```

#### **3. Запуск сервера**

Щоб запустити сервер, потрібно виконати команду:

```bash
uvicorn filename:app --reload
```

де `filename` – це ім'я файлу, в якому збережений код.

---

### **Що відбувається в коді?**

1. **Маршрут `/`** – повертає просте повідомлення (`async` не обов’язковий, бо тут немає асинхронних операцій).
2. **Маршрут `/slow`** – імітує довготривалий запит (3 секунди), показуючи, як працює `await asyncio.sleep()`.
3. **Маршрут `/parallel`** – виконує три асинхронні задачі паралельно, використовуючи `asyncio.gather()`.

Якщо відкрити `http://127.0.0.1:8000/parallel`, сервер поверне щось подібне:

```json
{
    "results": [
        {"Завдання 1": "Готово через 2 секунд"},
        {"Завдання 2": "Готово через 1 секунд"},
        {"Завдання 3": "Готово через 3 секунд"}
    ]
}
```

Порядок виконання залежить від часу очікування кожного завдання.

---

### **Чому асинхронний FastAPI краще за Flask?**

Flask працює **синхронно** і обробляє кожен запит окремо, що може призвести до блокування при високих навантаженнях.

FastAPI, завдяки **асинхронному виконанню**, дозволяє:

- обробляти більше запитів одночасно, не блокуючи сервер;
- масштабувати додатки без необхідності створення додаткових потоків або процесів;
- працювати з асинхронними клієнтами (`aiohttp`, `httpx`), зменшуючи час очікування.
